/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/7z-wasm@1.1.0/7zz.es6.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var SevenZip = function() {
	var r = import.meta.url;
	return function(e) {
		var t, n, o = void 0 !== (e = e || {}) ? e : {};
		o.ready = new Promise((function(r, e) {
			t = r, n = e
		})), o.noInitialRun = !0;
		var i, a = {};
		for (i in o) o.hasOwnProperty(i) && (a[i] = o[i]);
		var s, u, c, f, l, d = [],
			m = "./this.program",
			h = function(r, e) {
				throw e
			},
			p = "object" == typeof window,
			E = "function" == typeof importScripts,
			w = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node,
			v = "";
		w ? (v = E ? require("path").dirname(v) + "/" : __dirname + "/", s = function(r, e) {
			return f || (f = require("fs")), l || (l = require("path")), r = l.normalize(r), f.readFileSync(r, e ? null : "utf8")
		}, c = function(r) {
			var e = s(r, !0);
			return e.buffer || (e = new Uint8Array(e)), N(e.buffer), e
		}, u = function(r, e, t) {
			f || (f = require("fs")), l || (l = require("path")), r = l.normalize(r), f.readFile(r, (function(r, n) {
				r ? t(r) : e(n.buffer)
			}))
		}, process.argv.length > 1 && (m = process.argv[1].replace(/\\/g, "/")), d = process.argv.slice(2), process.on("uncaughtException", (function(r) {
			if (!(r instanceof Br)) throw r
		})), process.on("unhandledRejection", rr), h = function(r, e) {
			if (K()) throw process.exitCode = r, e;
			process.exit(r)
		}, o.inspect = function() {
			return "[Emscripten Module object]"
		}) : (p || E) && (E ? v = self.location.href : "undefined" != typeof document && document.currentScript && (v = document.currentScript.src), r && (v = r), v = 0 !== v.indexOf("blob:") ? v.substr(0, v.lastIndexOf("/") + 1) : "", s = function(r) {
			var e = new XMLHttpRequest;
			return e.open("GET", r, !1), e.send(null), e.responseText
		}, E && (c = function(r) {
			var e = new XMLHttpRequest;
			return e.open("GET", r, !1), e.responseType = "arraybuffer", e.send(null), new Uint8Array(e.response)
		}), u = function(r, e, t) {
			var n = new XMLHttpRequest;
			n.open("GET", r, !0), n.responseType = "arraybuffer", n.onload = function() {
				200 == n.status || 0 == n.status && n.response ? e(n.response) : t()
			}, n.onerror = t, n.send(null)
		});
		var g = o.print || console.log.bind(console),
			y = o.printErr || console.warn.bind(console);
		for (i in a) a.hasOwnProperty(i) && (o[i] = a[i]);
		a = null, o.arguments && (d = o.arguments), o.thisProgram && (m = o.thisProgram), o.quit && (h = o.quit);
		var _;
		o.wasmBinary && (_ = o.wasmBinary);
		var k, D = o.noExitRuntime || !0;
		"object" != typeof WebAssembly && rr("no native wasm support detected");
		var S, b = !1;

		function N(r, e) {
			r || rr("Assertion failed: " + e)
		}
		var O = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;

		function F(r, e, t) {
			for (var n = e + t, o = e; r[o] && !(o >= n);) ++o;
			if (o - e > 16 && r.subarray && O) return O.decode(r.subarray(e, o));
			for (var i = ""; e < o;) {
				var a = r[e++];
				if (128 & a) {
					var s = 63 & r[e++];
					if (192 != (224 & a)) {
						var u = 63 & r[e++];
						if ((a = 224 == (240 & a) ? (15 & a) << 12 | s << 6 | u : (7 & a) << 18 | s << 12 | u << 6 | 63 & r[e++]) < 65536) i += String.fromCharCode(a);
						else {
							var c = a - 65536;
							i += String.fromCharCode(55296 | c >> 10, 56320 | 1023 & c)
						}
					} else i += String.fromCharCode((31 & a) << 6 | s)
				} else i += String.fromCharCode(a)
			}
			return i
		}

		function T(r, e) {
			return r ? F(z, r, e) : ""
		}

		function P(r, e, t, n) {
			if (!(n > 0)) return 0;
			for (var o = t, i = t + n - 1, a = 0; a < r.length; ++a) {
				var s = r.charCodeAt(a);
				if (s >= 55296 && s <= 57343) s = 65536 + ((1023 & s) << 10) | 1023 & r.charCodeAt(++a);
				if (s <= 127) {
					if (t >= i) break;
					e[t++] = s
				} else if (s <= 2047) {
					if (t + 1 >= i) break;
					e[t++] = 192 | s >> 6, e[t++] = 128 | 63 & s
				} else if (s <= 65535) {
					if (t + 2 >= i) break;
					e[t++] = 224 | s >> 12, e[t++] = 128 | s >> 6 & 63, e[t++] = 128 | 63 & s
				} else {
					if (t + 3 >= i) break;
					e[t++] = 240 | s >> 18, e[t++] = 128 | s >> 12 & 63, e[t++] = 128 | s >> 6 & 63, e[t++] = 128 | 63 & s
				}
			}
			return e[t] = 0, t - o
		}

		function M(r, e, t) {
			return P(r, z, e, t)
		}

		function A(r) {
			for (var e = 0, t = 0; t < r.length; ++t) {
				var n = r.charCodeAt(t);
				n >= 55296 && n <= 57343 && (n = 65536 + ((1023 & n) << 10) | 1023 & r.charCodeAt(++t)), n <= 127 ? ++e : e += n <= 2047 ? 2 : n <= 65535 ? 3 : 4
			}
			return e
		}
		var R, C, z, L, I;
		"undefined" != typeof TextDecoder && new TextDecoder("utf-16le");

		function x(r) {
			var e = A(r) + 1,
				t = Cr(e);
			return t && P(r, C, t, e), t
		}

		function B(r) {
			var e = A(r) + 1,
				t = xr(e);
			return P(r, C, t, e), t
		}

		function j(r, e, t) {
			for (var n = 0; n < r.length; ++n) C[e++ >> 0] = r.charCodeAt(n);
			t || (C[e >> 0] = 0)
		}

		function U(r) {
			R = r, o.HEAP8 = C = new Int8Array(r), o.HEAP16 = L = new Int16Array(r), o.HEAP32 = I = new Int32Array(r), o.HEAPU8 = z = new Uint8Array(r), o.HEAPU16 = new Uint16Array(r), o.HEAPU32 = new Uint32Array(r), o.HEAPF32 = new Float32Array(r), o.HEAPF64 = new Float64Array(r)
		}
		o.INITIAL_MEMORY;
		var H, W = [],
			q = [],
			G = [],
			Y = [],
			X = 0;

		function K() {
			return D || X > 0
		}
		var V = 0,
			Q = null,
			Z = null;

		function $(r) {
			V++, o.monitorRunDependencies && o.monitorRunDependencies(V)
		}

		function J(r) {
			if (V--, o.monitorRunDependencies && o.monitorRunDependencies(V), 0 == V && (null !== Q && (clearInterval(Q), Q = null), Z)) {
				var e = Z;
				Z = null, e()
			}
		}

		function rr(r) {
			o.onAbort && o.onAbort(r), y(r += ""), b = !0, S = 1, r = "abort(" + r + "). Build with -s ASSERTIONS=1 for more info.";
			var e = new WebAssembly.RuntimeError(r);
			throw n(e), e
		}
		o.preloadedImages = {}, o.preloadedAudios = {};
		var er, tr, nr, or, ir = "data:application/octet-stream;base64,";

		function ar(r) {
			return r.startsWith(ir)
		}

		function sr(r) {
			return r.startsWith("file://")
		}

		function ur(r) {
			try {
				if (r == er && _) return new Uint8Array(_);
				if (c) return c(r);
				throw "both async and sync fetching of the wasm failed"
			} catch (r) {
				rr(r)
			}
		}

		function cr(r) {
			for (; r.length > 0;) {
				var e = r.shift();
				if ("function" != typeof e) {
					var t = e.func;
					"number" == typeof t ? void 0 === e.arg ? H.get(t)() : H.get(t)(e.arg) : t(void 0 === e.arg ? null : e.arg)
				} else e(o)
			}
		}

		function fr(r) {
			this.excPtr = r, this.ptr = r - 16, this.set_type = function(r) {
				I[this.ptr + 4 >> 2] = r
			}, this.get_type = function() {
				return I[this.ptr + 4 >> 2]
			}, this.set_destructor = function(r) {
				I[this.ptr + 8 >> 2] = r
			}, this.get_destructor = function() {
				return I[this.ptr + 8 >> 2]
			}, this.set_refcount = function(r) {
				I[this.ptr >> 2] = r
			}, this.set_caught = function(r) {
				r = r ? 1 : 0, C[this.ptr + 12 >> 0] = r
			}, this.get_caught = function() {
				return 0 != C[this.ptr + 12 >> 0]
			}, this.set_rethrown = function(r) {
				r = r ? 1 : 0, C[this.ptr + 13 >> 0] = r
			}, this.get_rethrown = function() {
				return 0 != C[this.ptr + 13 >> 0]
			}, this.init = function(r, e) {
				this.set_type(r), this.set_destructor(e), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1)
			}, this.add_ref = function() {
				var r = I[this.ptr >> 2];
				I[this.ptr >> 2] = r + 1
			}, this.release_ref = function() {
				var r = I[this.ptr >> 2];
				return I[this.ptr >> 2] = r - 1, 1 === r
			}
		}
		o.locateFile ? ar(er = "7zz.wasm") || (tr = er, er = o.locateFile ? o.locateFile(tr, v) : v + tr) : er = new URL("7zz.wasm", import.meta.url).toString();

		function lr(r, e) {
			var t = new Date(1e3 * I[r >> 2]);
			I[e >> 2] = t.getUTCSeconds(), I[e + 4 >> 2] = t.getUTCMinutes(), I[e + 8 >> 2] = t.getUTCHours(), I[e + 12 >> 2] = t.getUTCDate(), I[e + 16 >> 2] = t.getUTCMonth(), I[e + 20 >> 2] = t.getUTCFullYear() - 1900, I[e + 24 >> 2] = t.getUTCDay(), I[e + 36 >> 2] = 0, I[e + 32 >> 2] = 0;
			var n = Date.UTC(t.getUTCFullYear(), 0, 1, 0, 0, 0, 0),
				o = (t.getTime() - n) / 864e5 | 0;
			return I[e + 28 >> 2] = o, lr.GMTString || (lr.GMTString = x("GMT")), I[e + 40 >> 2] = lr.GMTString, e
		}

		function dr() {
			dr.called || (dr.called = !0, function() {
				var r = (new Date).getFullYear(),
					e = new Date(r, 0, 1),
					t = new Date(r, 6, 1),
					n = e.getTimezoneOffset(),
					o = t.getTimezoneOffset(),
					i = Math.max(n, o);

				function a(r) {
					var e = r.toTimeString().match(/\(([A-Za-z ]+)\)$/);
					return e ? e[1] : "GMT"
				}
				I[Ir() >> 2] = 60 * i, I[Lr() >> 2] = Number(n != o);
				var s = a(e),
					u = a(t),
					c = x(s),
					f = x(u);
				o < n ? (I[zr() >> 2] = c, I[zr() + 4 >> 2] = f) : (I[zr() >> 2] = f, I[zr() + 4 >> 2] = c)
			}())
		}
		var mr = {
			splitPath: function(r) {
				return /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(r).slice(1)
			},
			normalizeArray: function(r, e) {
				for (var t = 0, n = r.length - 1; n >= 0; n--) {
					var o = r[n];
					"." === o ? r.splice(n, 1) : ".." === o ? (r.splice(n, 1), t++) : t && (r.splice(n, 1), t--)
				}
				if (e)
					for (; t; t--) r.unshift("..");
				return r
			},
			normalize: function(r) {
				var e = "/" === r.charAt(0),
					t = "/" === r.substr(-1);
				return (r = mr.normalizeArray(r.split("/").filter((function(r) {
					return !!r
				})), !e).join("/")) || e || (r = "."), r && t && (r += "/"), (e ? "/" : "") + r
			},
			dirname: function(r) {
				var e = mr.splitPath(r),
					t = e[0],
					n = e[1];
				return t || n ? (n && (n = n.substr(0, n.length - 1)), t + n) : "."
			},
			basename: function(r) {
				if ("/" === r) return "/";
				var e = (r = (r = mr.normalize(r)).replace(/\/$/, "")).lastIndexOf("/");
				return -1 === e ? r : r.substr(e + 1)
			},
			extname: function(r) {
				return mr.splitPath(r)[3]
			},
			join: function() {
				var r = Array.prototype.slice.call(arguments, 0);
				return mr.normalize(r.join("/"))
			},
			join2: function(r, e) {
				return mr.normalize(r + "/" + e)
			}
		};
		var hr = {
				resolve: function() {
					for (var r = "", e = !1, t = arguments.length - 1; t >= -1 && !e; t--) {
						var n = t >= 0 ? arguments[t] : _r.cwd();
						if ("string" != typeof n) throw new TypeError("Arguments to path.resolve must be strings");
						if (!n) return "";
						r = n + "/" + r, e = "/" === n.charAt(0)
					}
					return (e ? "/" : "") + (r = mr.normalizeArray(r.split("/").filter((function(r) {
						return !!r
					})), !e).join("/")) || "."
				},
				relative: function(r, e) {
					function t(r) {
						for (var e = 0; e < r.length && "" === r[e]; e++);
						for (var t = r.length - 1; t >= 0 && "" === r[t]; t--);
						return e > t ? [] : r.slice(e, t - e + 1)
					}
					r = hr.resolve(r).substr(1), e = hr.resolve(e).substr(1);
					for (var n = t(r.split("/")), o = t(e.split("/")), i = Math.min(n.length, o.length), a = i, s = 0; s < i; s++)
						if (n[s] !== o[s]) {
							a = s;
							break
						} var u = [];
					for (s = a; s < n.length; s++) u.push("..");
					return (u = u.concat(o.slice(a))).join("/")
				}
			},
			pr = {
				ttys: [],
				init: function() {},
				shutdown: function() {},
				register: function(r, e) {
					pr.ttys[r] = {
						input: [],
						output: [],
						ops: e
					}, _r.registerDevice(r, pr.stream_ops)
				},
				stream_ops: {
					open: function(r) {
						var e = pr.ttys[r.node.rdev];
						if (!e) throw new _r.ErrnoError(43);
						r.tty = e, r.seekable = !1
					},
					close: function(r) {
						r.tty.ops.flush(r.tty)
					},
					flush: function(r) {
						r.tty.ops.flush(r.tty)
					},
					read: function(r, e, t, n, o) {
						if (!r.tty || !r.tty.ops.get_char) throw new _r.ErrnoError(60);
						for (var i = 0, a = 0; a < n; a++) {
							var s;
							try {
								s = r.tty.ops.get_char(r.tty)
							} catch (r) {
								throw new _r.ErrnoError(29)
							}
							if (void 0 === s && 0 === i) throw new _r.ErrnoError(6);
							if (null == s) break;
							i++, e[t + a] = s
						}
						return i && (r.node.timestamp = Date.now()), i
					},
					write: function(r, e, t, n, o) {
						if (!r.tty || !r.tty.ops.put_char) throw new _r.ErrnoError(60);
						try {
							for (var i = 0; i < n; i++) r.tty.ops.put_char(r.tty, e[t + i])
						} catch (r) {
							throw new _r.ErrnoError(29)
						}
						return n && (r.node.timestamp = Date.now()), i
					}
				},
				default_tty_ops: {
					get_char: function(r) {
						if (!r.input.length) {
							var e = null;
							if (w) {
								var t = Buffer.alloc(256),
									n = 0;
								try {
									n = f.readSync(process.stdin.fd, t, 0, 256, null)
								} catch (r) {
									if (!r.toString().includes("EOF")) throw r;
									n = 0
								}
								e = n > 0 ? t.slice(0, n).toString("utf-8") : null
							} else "undefined" != typeof window && "function" == typeof window.prompt ? null !== (e = window.prompt("Input: ")) && (e += "\n") : "function" == typeof readline && null !== (e = readline()) && (e += "\n");
							if (!e) return null;
							r.input = Mr(e, !0)
						}
						return r.input.shift()
					},
					put_char: function(r, e) {
						null === e || 10 === e ? (g(F(r.output, 0)), r.output = []) : 0 != e && r.output.push(e)
					},
					flush: function(r) {
						r.output && r.output.length > 0 && (g(F(r.output, 0)), r.output = [])
					}
				},
				default_tty1_ops: {
					put_char: function(r, e) {
						null === e || 10 === e ? (y(F(r.output, 0)), r.output = []) : 0 != e && r.output.push(e)
					},
					flush: function(r) {
						r.output && r.output.length > 0 && (y(F(r.output, 0)), r.output = [])
					}
				}
			};

		function Er(r) {
			rr()
		}
		var wr = {
			ops_table: null,
			mount: function(r) {
				return wr.createNode(null, "/", 16895, 0)
			},
			createNode: function(r, e, t, n) {
				if (_r.isBlkdev(t) || _r.isFIFO(t)) throw new _r.ErrnoError(63);
				wr.ops_table || (wr.ops_table = {
					dir: {
						node: {
							getattr: wr.node_ops.getattr,
							setattr: wr.node_ops.setattr,
							lookup: wr.node_ops.lookup,
							mknod: wr.node_ops.mknod,
							rename: wr.node_ops.rename,
							unlink: wr.node_ops.unlink,
							rmdir: wr.node_ops.rmdir,
							readdir: wr.node_ops.readdir,
							symlink: wr.node_ops.symlink
						},
						stream: {
							llseek: wr.stream_ops.llseek
						}
					},
					file: {
						node: {
							getattr: wr.node_ops.getattr,
							setattr: wr.node_ops.setattr
						},
						stream: {
							llseek: wr.stream_ops.llseek,
							read: wr.stream_ops.read,
							write: wr.stream_ops.write,
							allocate: wr.stream_ops.allocate,
							mmap: wr.stream_ops.mmap,
							msync: wr.stream_ops.msync
						}
					},
					link: {
						node: {
							getattr: wr.node_ops.getattr,
							setattr: wr.node_ops.setattr,
							readlink: wr.node_ops.readlink
						},
						stream: {}
					},
					chrdev: {
						node: {
							getattr: wr.node_ops.getattr,
							setattr: wr.node_ops.setattr
						},
						stream: _r.chrdev_stream_ops
					}
				});
				var o = _r.createNode(r, e, t, n);
				return _r.isDir(o.mode) ? (o.node_ops = wr.ops_table.dir.node, o.stream_ops = wr.ops_table.dir.stream, o.contents = {}) : _r.isFile(o.mode) ? (o.node_ops = wr.ops_table.file.node, o.stream_ops = wr.ops_table.file.stream, o.usedBytes = 0, o.contents = null) : _r.isLink(o.mode) ? (o.node_ops = wr.ops_table.link.node, o.stream_ops = wr.ops_table.link.stream) : _r.isChrdev(o.mode) && (o.node_ops = wr.ops_table.chrdev.node, o.stream_ops = wr.ops_table.chrdev.stream), o.timestamp = Date.now(), r && (r.contents[e] = o, r.timestamp = o.timestamp), o
			},
			getFileDataAsTypedArray: function(r) {
				return r.contents ? r.contents.subarray ? r.contents.subarray(0, r.usedBytes) : new Uint8Array(r.contents) : new Uint8Array(0)
			},
			expandFileStorage: function(r, e) {
				var t = r.contents ? r.contents.length : 0;
				if (!(t >= e)) {
					e = Math.max(e, t * (t < 1048576 ? 2 : 1.125) >>> 0), 0 != t && (e = Math.max(e, 256));
					var n = r.contents;
					r.contents = new Uint8Array(e), r.usedBytes > 0 && r.contents.set(n.subarray(0, r.usedBytes), 0)
				}
			},
			resizeFileStorage: function(r, e) {
				if (r.usedBytes != e)
					if (0 == e) r.contents = null, r.usedBytes = 0;
					else {
						var t = r.contents;
						r.contents = new Uint8Array(e), t && r.contents.set(t.subarray(0, Math.min(e, r.usedBytes))), r.usedBytes = e
					}
			},
			node_ops: {
				getattr: function(r) {
					var e = {};
					return e.dev = _r.isChrdev(r.mode) ? r.id : 1, e.ino = r.id, e.mode = r.mode, e.nlink = 1, e.uid = 0, e.gid = 0, e.rdev = r.rdev, _r.isDir(r.mode) ? e.size = 4096 : _r.isFile(r.mode) ? e.size = r.usedBytes : _r.isLink(r.mode) ? e.size = r.link.length : e.size = 0, e.atime = new Date(r.timestamp), e.mtime = new Date(r.timestamp), e.ctime = new Date(r.timestamp), e.blksize = 4096, e.blocks = Math.ceil(e.size / e.blksize), e
				},
				setattr: function(r, e) {
					void 0 !== e.mode && (r.mode = e.mode), void 0 !== e.timestamp && (r.timestamp = e.timestamp), void 0 !== e.size && wr.resizeFileStorage(r, e.size)
				},
				lookup: function(r, e) {
					throw _r.genericErrors[44]
				},
				mknod: function(r, e, t, n) {
					return wr.createNode(r, e, t, n)
				},
				rename: function(r, e, t) {
					if (_r.isDir(r.mode)) {
						var n;
						try {
							n = _r.lookupNode(e, t)
						} catch (r) {}
						if (n)
							for (var o in n.contents) throw new _r.ErrnoError(55)
					}
					delete r.parent.contents[r.name], r.parent.timestamp = Date.now(), r.name = t, e.contents[t] = r, e.timestamp = r.parent.timestamp, r.parent = e
				},
				unlink: function(r, e) {
					delete r.contents[e], r.timestamp = Date.now()
				},
				rmdir: function(r, e) {
					var t = _r.lookupNode(r, e);
					for (var n in t.contents) throw new _r.ErrnoError(55);
					delete r.contents[e], r.timestamp = Date.now()
				},
				readdir: function(r) {
					var e = [".", ".."];
					for (var t in r.contents) r.contents.hasOwnProperty(t) && e.push(t);
					return e
				},
				symlink: function(r, e, t) {
					var n = wr.createNode(r, e, 41471, 0);
					return n.link = t, n
				},
				readlink: function(r) {
					if (!_r.isLink(r.mode)) throw new _r.ErrnoError(28);
					return r.link
				}
			},
			stream_ops: {
				read: function(r, e, t, n, o) {
					var i = r.node.contents;
					if (o >= r.node.usedBytes) return 0;
					var a = Math.min(r.node.usedBytes - o, n);
					if (a > 8 && i.subarray) e.set(i.subarray(o, o + a), t);
					else
						for (var s = 0; s < a; s++) e[t + s] = i[o + s];
					return a
				},
				write: function(r, e, t, n, o, i) {
					if (e.buffer === C.buffer && (i = !1), !n) return 0;
					var a = r.node;
					if (a.timestamp = Date.now(), e.subarray && (!a.contents || a.contents.subarray)) {
						if (i) return a.contents = e.subarray(t, t + n), a.usedBytes = n, n;
						if (0 === a.usedBytes && 0 === o) return a.contents = e.slice(t, t + n), a.usedBytes = n, n;
						if (o + n <= a.usedBytes) return a.contents.set(e.subarray(t, t + n), o), n
					}
					if (wr.expandFileStorage(a, o + n), a.contents.subarray && e.subarray) a.contents.set(e.subarray(t, t + n), o);
					else
						for (var s = 0; s < n; s++) a.contents[o + s] = e[t + s];
					return a.usedBytes = Math.max(a.usedBytes, o + n), n
				},
				llseek: function(r, e, t) {
					var n = e;
					if (1 === t ? n += r.position : 2 === t && _r.isFile(r.node.mode) && (n += r.node.usedBytes), n < 0) throw new _r.ErrnoError(28);
					return n
				},
				allocate: function(r, e, t) {
					wr.expandFileStorage(r.node, e + t), r.node.usedBytes = Math.max(r.node.usedBytes, e + t)
				},
				mmap: function(r, e, t, n, o, i) {
					if (0 !== e) throw new _r.ErrnoError(28);
					if (!_r.isFile(r.node.mode)) throw new _r.ErrnoError(43);
					var a, s, u = r.node.contents;
					if (2 & i || u.buffer !== R) {
						if ((n > 0 || n + t < u.length) && (u = u.subarray ? u.subarray(n, n + t) : Array.prototype.slice.call(u, n, n + t)), s = !0, !(a = Er())) throw new _r.ErrnoError(48);
						C.set(u, a)
					} else s = !1, a = u.byteOffset;
					return {
						ptr: a,
						allocated: s
					}
				},
				msync: function(r, e, t, n, o) {
					if (!_r.isFile(r.node.mode)) throw new _r.ErrnoError(43);
					if (2 & o) return 0;
					wr.stream_ops.write(r, e, 0, n, t, !1);
					return 0
				}
			}
		};
		var vr = {},
			gr = {
				isWindows: !1,
				staticInit: function() {
					gr.isWindows = !!process.platform.match(/^win/);
					var r = process.binding("constants");
					r.fs && (r = r.fs), gr.flagsForNodeMap = {
						1024: r.O_APPEND,
						64: r.O_CREAT,
						128: r.O_EXCL,
						256: r.O_NOCTTY,
						0: r.O_RDONLY,
						2: r.O_RDWR,
						4096: r.O_SYNC,
						512: r.O_TRUNC,
						1: r.O_WRONLY
					}
				},
				convertNodeCode: function(r) {
					var e = r.code;
					return vr[e]
				},
				mount: function(r) {
					return gr.createNode(null, "/", gr.getMode(r.opts.root), 0)
				},
				createNode: function(r, e, t, n) {
					if (!_r.isDir(t) && !_r.isFile(t) && !_r.isLink(t)) throw new _r.ErrnoError(28);
					var o = _r.createNode(r, e, t);
					return o.node_ops = gr.node_ops, o.stream_ops = gr.stream_ops, o
				},
				getMode: function(r) {
					var e;
					try {
						e = Tr.lstatSync(r), gr.isWindows && (e.mode = e.mode | (292 & e.mode) >> 2)
					} catch (r) {
						if (!r.code) throw r;
						throw new _r.ErrnoError(gr.convertNodeCode(r))
					}
					return e.mode
				},
				realPath: function(r) {
					for (var e = []; r.parent !== r;) e.push(r.name), r = r.parent;
					return e.push(r.mount.opts.root), e.reverse(), mr.join.apply(null, e)
				},
				flagsForNode: function(r) {
					r &= -2097153, r &= -2049, r &= -32769, r &= -524289;
					var e = 0;
					for (var t in gr.flagsForNodeMap) r & t && (e |= gr.flagsForNodeMap[t], r ^= t);
					if (r) throw new _r.ErrnoError(28);
					return e
				},
				node_ops: {
					getattr: function(r) {
						var e, t = gr.realPath(r);
						try {
							e = Tr.lstatSync(t)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
						return gr.isWindows && !e.blksize && (e.blksize = 4096), gr.isWindows && !e.blocks && (e.blocks = (e.size + e.blksize - 1) / e.blksize | 0), {
							dev: e.dev,
							ino: e.ino,
							mode: e.mode,
							nlink: e.nlink,
							uid: e.uid,
							gid: e.gid,
							rdev: e.rdev,
							size: e.size,
							atime: e.atime,
							mtime: e.mtime,
							ctime: e.ctime,
							blksize: e.blksize,
							blocks: e.blocks
						}
					},
					setattr: function(r, e) {
						var t = gr.realPath(r);
						try {
							if (void 0 !== e.mode && (Tr.chmodSync(t, e.mode), r.mode = e.mode), void 0 !== e.timestamp) {
								var n = new Date(e.timestamp);
								Tr.utimesSync(t, n, n)
							}
							void 0 !== e.size && Tr.truncateSync(t, e.size)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					lookup: function(r, e) {
						var t = mr.join2(gr.realPath(r), e),
							n = gr.getMode(t);
						return gr.createNode(r, e, n)
					},
					mknod: function(r, e, t, n) {
						var o = gr.createNode(r, e, t, n),
							i = gr.realPath(o);
						try {
							_r.isDir(o.mode) ? Tr.mkdirSync(i, o.mode) : Tr.writeFileSync(i, "", {
								mode: o.mode
							})
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
						return o
					},
					rename: function(r, e, t) {
						var n = gr.realPath(r),
							o = mr.join2(gr.realPath(e), t);
						try {
							Tr.renameSync(n, o)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
						r.name = t
					},
					unlink: function(r, e) {
						var t = mr.join2(gr.realPath(r), e);
						try {
							Tr.unlinkSync(t)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					rmdir: function(r, e) {
						var t = mr.join2(gr.realPath(r), e);
						try {
							Tr.rmdirSync(t)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					readdir: function(r) {
						var e = gr.realPath(r);
						try {
							return Tr.readdirSync(e)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					symlink: function(r, e, t) {
						var n = mr.join2(gr.realPath(r), e);
						try {
							Tr.symlinkSync(t, n)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					readlink: function(r) {
						var e = gr.realPath(r);
						try {
							return e = Tr.readlinkSync(e), e = Pr.relative(Pr.resolve(r.mount.opts.root), e)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					}
				},
				stream_ops: {
					open: function(r) {
						var e = gr.realPath(r.node);
						try {
							_r.isFile(r.node.mode) && (r.nfd = Tr.openSync(e, gr.flagsForNode(r.flags)))
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					close: function(r) {
						try {
							_r.isFile(r.node.mode) && r.nfd && Tr.closeSync(r.nfd)
						} catch (r) {
							if (!r.code) throw r;
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					read: function(r, e, t, n, o) {
						if (0 === n) return 0;
						try {
							return Tr.readSync(r.nfd, Buffer.from(e.buffer), t, n, o)
						} catch (r) {
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					write: function(r, e, t, n, o) {
						try {
							return Tr.writeSync(r.nfd, Buffer.from(e.buffer), t, n, o)
						} catch (r) {
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
					},
					llseek: function(r, e, t) {
						var n = e;
						if (1 === t) n += r.position;
						else if (2 === t && _r.isFile(r.node.mode)) try {
							n += Tr.fstatSync(r.nfd).size
						} catch (r) {
							throw new _r.ErrnoError(gr.convertNodeCode(r))
						}
						if (n < 0) throw new _r.ErrnoError(28);
						return n
					},
					mmap: function(r, e, t, n, o, i) {
						if (0 !== e) throw new _r.ErrnoError(28);
						if (!_r.isFile(r.node.mode)) throw new _r.ErrnoError(43);
						var a = Er();
						return gr.stream_ops.read(r, C, a, t, n), {
							ptr: a,
							allocated: !0
						}
					},
					msync: function(r, e, t, n, o) {
						if (!_r.isFile(r.node.mode)) throw new _r.ErrnoError(43);
						if (2 & o) return 0;
						gr.stream_ops.write(r, e, 0, n, t, !1);
						return 0
					}
				}
			},
			yr = {
				DIR_MODE: 16895,
				FILE_MODE: 33279,
				reader: null,
				mount: function(r) {
					N(E), yr.reader || (yr.reader = new FileReaderSync);
					var e = yr.createNode(null, "/", yr.DIR_MODE, 0),
						t = {};

					function n(r) {
						for (var n = r.split("/"), o = e, i = 0; i < n.length - 1; i++) {
							var a = n.slice(0, i + 1).join("/");
							t[a] || (t[a] = yr.createNode(o, n[i], yr.DIR_MODE, 0)), o = t[a]
						}
						return o
					}

					function o(r) {
						var e = r.split("/");
						return e[e.length - 1]
					}
					return Array.prototype.forEach.call(r.opts.files || [], (function(r) {
						yr.createNode(n(r.name), o(r.name), yr.FILE_MODE, 0, r, r.lastModifiedDate)
					})), (r.opts.blobs || []).forEach((function(r) {
						yr.createNode(n(r.name), o(r.name), yr.FILE_MODE, 0, r.data)
					})), (r.opts.packages || []).forEach((function(r) {
						r.metadata.files.forEach((function(e) {
							var t = e.filename.substr(1);
							yr.createNode(n(t), o(t), yr.FILE_MODE, 0, r.blob.slice(e.start, e.end))
						}))
					})), e
				},
				createNode: function(r, e, t, n, o, i) {
					var a = _r.createNode(r, e, t);
					return a.mode = t, a.node_ops = yr.node_ops, a.stream_ops = yr.stream_ops, a.timestamp = (i || new Date).getTime(), N(yr.FILE_MODE !== yr.DIR_MODE), t === yr.FILE_MODE ? (a.size = o.size, a.contents = o) : (a.size = 4096, a.contents = {}), r && (r.contents[e] = a), a
				},
				node_ops: {
					getattr: function(r) {
						return {
							dev: 1,
							ino: r.id,
							mode: r.mode,
							nlink: 1,
							uid: 0,
							gid: 0,
							rdev: void 0,
							size: r.size,
							atime: new Date(r.timestamp),
							mtime: new Date(r.timestamp),
							ctime: new Date(r.timestamp),
							blksize: 4096,
							blocks: Math.ceil(r.size / 4096)
						}
					},
					setattr: function(r, e) {
						void 0 !== e.mode && (r.mode = e.mode), void 0 !== e.timestamp && (r.timestamp = e.timestamp)
					},
					lookup: function(r, e) {
						throw new _r.ErrnoError(44)
					},
					mknod: function(r, e, t, n) {
						throw new _r.ErrnoError(63)
					},
					rename: function(r, e, t) {
						throw new _r.ErrnoError(63)
					},
					unlink: function(r, e) {
						throw new _r.ErrnoError(63)
					},
					rmdir: function(r, e) {
						throw new _r.ErrnoError(63)
					},
					readdir: function(r) {
						var e = [".", ".."];
						for (var t in r.contents) r.contents.hasOwnProperty(t) && e.push(t);
						return e
					},
					symlink: function(r, e, t) {
						throw new _r.ErrnoError(63)
					},
					readlink: function(r) {
						throw new _r.ErrnoError(63)
					}
				},
				stream_ops: {
					read: function(r, e, t, n, o) {
						if (o >= r.node.size) return 0;
						var i = r.node.contents.slice(o, o + n),
							a = yr.reader.readAsArrayBuffer(i);
						return e.set(new Uint8Array(a), t), i.size
					},
					write: function(r, e, t, n, o) {
						throw new _r.ErrnoError(29)
					},
					llseek: function(r, e, t) {
						var n = e;
						if (1 === t ? n += r.position : 2 === t && _r.isFile(r.node.mode) && (n += r.node.size), n < 0) throw new _r.ErrnoError(28);
						return n
					}
				}
			},
			_r = {
				root: null,
				mounts: [],
				devices: {},
				streams: [],
				nextInode: 1,
				nameTable: null,
				currentPath: "/",
				initialized: !1,
				ignorePermissions: !0,
				trackingDelegate: {},
				tracking: {
					openFlags: {
						READ: 1,
						WRITE: 2
					}
				},
				ErrnoError: null,
				genericErrors: {},
				filesystems: null,
				syncFSRequests: 0,
				lookupPath: function(r, e) {
					if (e = e || {}, !(r = hr.resolve(_r.cwd(), r))) return {
						path: "",
						node: null
					};
					var t = {
						follow_mount: !0,
						recurse_count: 0
					};
					for (var n in t) void 0 === e[n] && (e[n] = t[n]);
					if (e.recurse_count > 8) throw new _r.ErrnoError(32);
					for (var o = mr.normalizeArray(r.split("/").filter((function(r) {
							return !!r
						})), !1), i = _r.root, a = "/", s = 0; s < o.length; s++) {
						var u = s === o.length - 1;
						if (u && e.parent) break;
						if (i = _r.lookupNode(i, o[s]), a = mr.join2(a, o[s]), _r.isMountpoint(i) && (!u || u && e.follow_mount) && (i = i.mounted.root), !u || e.follow)
							for (var c = 0; _r.isLink(i.mode);) {
								var f = _r.readlink(a);
								if (a = hr.resolve(mr.dirname(a), f), i = _r.lookupPath(a, {
										recurse_count: e.recurse_count
									}).node, c++ > 40) throw new _r.ErrnoError(32)
							}
					}
					return {
						path: a,
						node: i
					}
				},
				getPath: function(r) {
					for (var e;;) {
						if (_r.isRoot(r)) {
							var t = r.mount.mountpoint;
							return e ? "/" !== t[t.length - 1] ? t + "/" + e : t + e : t
						}
						e = e ? r.name + "/" + e : r.name, r = r.parent
					}
				},
				hashName: function(r, e) {
					for (var t = 0, n = 0; n < e.length; n++) t = (t << 5) - t + e.charCodeAt(n) | 0;
					return (r + t >>> 0) % _r.nameTable.length
				},
				hashAddNode: function(r) {
					var e = _r.hashName(r.parent.id, r.name);
					r.name_next = _r.nameTable[e], _r.nameTable[e] = r
				},
				hashRemoveNode: function(r) {
					var e = _r.hashName(r.parent.id, r.name);
					if (_r.nameTable[e] === r) _r.nameTable[e] = r.name_next;
					else
						for (var t = _r.nameTable[e]; t;) {
							if (t.name_next === r) {
								t.name_next = r.name_next;
								break
							}
							t = t.name_next
						}
				},
				lookupNode: function(r, e) {
					var t = _r.mayLookup(r);
					if (t) throw new _r.ErrnoError(t, r);
					for (var n = _r.hashName(r.id, e), o = _r.nameTable[n]; o; o = o.name_next) {
						var i = o.name;
						if (o.parent.id === r.id && i === e) return o
					}
					return _r.lookup(r, e)
				},
				createNode: function(r, e, t, n) {
					var o = new _r.FSNode(r, e, t, n);
					return _r.hashAddNode(o), o
				},
				destroyNode: function(r) {
					_r.hashRemoveNode(r)
				},
				isRoot: function(r) {
					return r === r.parent
				},
				isMountpoint: function(r) {
					return !!r.mounted
				},
				isFile: function(r) {
					return 32768 == (61440 & r)
				},
				isDir: function(r) {
					return 16384 == (61440 & r)
				},
				isLink: function(r) {
					return 40960 == (61440 & r)
				},
				isChrdev: function(r) {
					return 8192 == (61440 & r)
				},
				isBlkdev: function(r) {
					return 24576 == (61440 & r)
				},
				isFIFO: function(r) {
					return 4096 == (61440 & r)
				},
				isSocket: function(r) {
					return 49152 == (49152 & r)
				},
				flagModes: {
					r: 0,
					"r+": 2,
					w: 577,
					"w+": 578,
					a: 1089,
					"a+": 1090
				},
				modeStringToFlags: function(r) {
					var e = _r.flagModes[r];
					if (void 0 === e) throw new Error("Unknown file open mode: " + r);
					return e
				},
				flagsToPermissionString: function(r) {
					var e = ["r", "w", "rw"][3 & r];
					return 512 & r && (e += "w"), e
				},
				nodePermissions: function(r, e) {
					return _r.ignorePermissions || (!e.includes("r") || 292 & r.mode) && (!e.includes("w") || 146 & r.mode) && (!e.includes("x") || 73 & r.mode) ? 0 : 2
				},
				mayLookup: function(r) {
					var e = _r.nodePermissions(r, "x");
					return e || (r.node_ops.lookup ? 0 : 2)
				},
				mayCreate: function(r, e) {
					try {
						_r.lookupNode(r, e);
						return 20
					} catch (r) {}
					return _r.nodePermissions(r, "wx")
				},
				mayDelete: function(r, e, t) {
					var n;
					try {
						n = _r.lookupNode(r, e)
					} catch (r) {
						return r.errno
					}
					var o = _r.nodePermissions(r, "wx");
					if (o) return o;
					if (t) {
						if (!_r.isDir(n.mode)) return 54;
						if (_r.isRoot(n) || _r.getPath(n) === _r.cwd()) return 10
					} else if (_r.isDir(n.mode)) return 31;
					return 0
				},
				mayOpen: function(r, e) {
					return r ? _r.isLink(r.mode) ? 32 : _r.isDir(r.mode) && ("r" !== _r.flagsToPermissionString(e) || 512 & e) ? 31 : _r.nodePermissions(r, _r.flagsToPermissionString(e)) : 44
				},
				MAX_OPEN_FDS: 4096,
				nextfd: function(r, e) {
					r = r || 0, e = e || _r.MAX_OPEN_FDS;
					for (var t = r; t <= e; t++)
						if (!_r.streams[t]) return t;
					throw new _r.ErrnoError(33)
				},
				getStream: function(r) {
					return _r.streams[r]
				},
				createStream: function(r, e, t) {
					_r.FSStream || (_r.FSStream = function() {}, _r.FSStream.prototype = {
						object: {
							get: function() {
								return this.node
							},
							set: function(r) {
								this.node = r
							}
						},
						isRead: {
							get: function() {
								return 1 != (2097155 & this.flags)
							}
						},
						isWrite: {
							get: function() {
								return 0 != (2097155 & this.flags)
							}
						},
						isAppend: {
							get: function() {
								return 1024 & this.flags
							}
						}
					});
					var n = new _r.FSStream;
					for (var o in r) n[o] = r[o];
					r = n;
					var i = _r.nextfd(e, t);
					return r.fd = i, _r.streams[i] = r, r
				},
				closeStream: function(r) {
					_r.streams[r] = null
				},
				chrdev_stream_ops: {
					open: function(r) {
						var e = _r.getDevice(r.node.rdev);
						r.stream_ops = e.stream_ops, r.stream_ops.open && r.stream_ops.open(r)
					},
					llseek: function() {
						throw new _r.ErrnoError(70)
					}
				},
				major: function(r) {
					return r >> 8
				},
				minor: function(r) {
					return 255 & r
				},
				makedev: function(r, e) {
					return r << 8 | e
				},
				registerDevice: function(r, e) {
					_r.devices[r] = {
						stream_ops: e
					}
				},
				getDevice: function(r) {
					return _r.devices[r]
				},
				getMounts: function(r) {
					for (var e = [], t = [r]; t.length;) {
						var n = t.pop();
						e.push(n), t.push.apply(t, n.mounts)
					}
					return e
				},
				syncfs: function(r, e) {
					"function" == typeof r && (e = r, r = !1), _r.syncFSRequests++, _r.syncFSRequests > 1 && y("warning: " + _r.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
					var t = _r.getMounts(_r.root.mount),
						n = 0;

					function o(r) {
						return _r.syncFSRequests--, e(r)
					}

					function i(r) {
						if (r) return i.errored ? void 0 : (i.errored = !0, o(r));
						++n >= t.length && o(null)
					}
					t.forEach((function(e) {
						if (!e.type.syncfs) return i(null);
						e.type.syncfs(e, r, i)
					}))
				},
				mount: function(r, e, t) {
					var n, o = "/" === t,
						i = !t;
					if (o && _r.root) throw new _r.ErrnoError(10);
					if (!o && !i) {
						var a = _r.lookupPath(t, {
							follow_mount: !1
						});
						if (t = a.path, n = a.node, _r.isMountpoint(n)) throw new _r.ErrnoError(10);
						if (!_r.isDir(n.mode)) throw new _r.ErrnoError(54)
					}
					var s = {
							type: r,
							opts: e,
							mountpoint: t,
							mounts: []
						},
						u = r.mount(s);
					return u.mount = s, s.root = u, o ? _r.root = u : n && (n.mounted = s, n.mount && n.mount.mounts.push(s)), u
				},
				unmount: function(r) {
					var e = _r.lookupPath(r, {
						follow_mount: !1
					});
					if (!_r.isMountpoint(e.node)) throw new _r.ErrnoError(28);
					var t = e.node,
						n = t.mounted,
						o = _r.getMounts(n);
					Object.keys(_r.nameTable).forEach((function(r) {
						for (var e = _r.nameTable[r]; e;) {
							var t = e.name_next;
							o.includes(e.mount) && _r.destroyNode(e), e = t
						}
					})), t.mounted = null;
					var i = t.mount.mounts.indexOf(n);
					t.mount.mounts.splice(i, 1)
				},
				lookup: function(r, e) {
					return r.node_ops.lookup(r, e)
				},
				mknod: function(r, e, t) {
					var n = _r.lookupPath(r, {
							parent: !0
						}).node,
						o = mr.basename(r);
					if (!o || "." === o || ".." === o) throw new _r.ErrnoError(28);
					var i = _r.mayCreate(n, o);
					if (i) throw new _r.ErrnoError(i);
					if (!n.node_ops.mknod) throw new _r.ErrnoError(63);
					return n.node_ops.mknod(n, o, e, t)
				},
				create: function(r, e) {
					return e = void 0 !== e ? e : 438, e &= 4095, e |= 32768, _r.mknod(r, e, 0)
				},
				mkdir: function(r, e) {
					return e = void 0 !== e ? e : 511, e &= 1023, e |= 16384, _r.mknod(r, e, 0)
				},
				mkdirTree: function(r, e) {
					for (var t = r.split("/"), n = "", o = 0; o < t.length; ++o)
						if (t[o]) {
							n += "/" + t[o];
							try {
								_r.mkdir(n, e)
							} catch (r) {
								if (20 != r.errno) throw r
							}
						}
				},
				mkdev: function(r, e, t) {
					return void 0 === t && (t = e, e = 438), e |= 8192, _r.mknod(r, e, t)
				},
				symlink: function(r, e) {
					if (!hr.resolve(r)) throw new _r.ErrnoError(44);
					var t = _r.lookupPath(e, {
						parent: !0
					}).node;
					if (!t) throw new _r.ErrnoError(44);
					var n = mr.basename(e),
						o = _r.mayCreate(t, n);
					if (o) throw new _r.ErrnoError(o);
					if (!t.node_ops.symlink) throw new _r.ErrnoError(63);
					return t.node_ops.symlink(t, n, r)
				},
				rename: function(r, e) {
					var t, n, o = mr.dirname(r),
						i = mr.dirname(e),
						a = mr.basename(r),
						s = mr.basename(e);
					if (t = _r.lookupPath(r, {
							parent: !0
						}).node, n = _r.lookupPath(e, {
							parent: !0
						}).node, !t || !n) throw new _r.ErrnoError(44);
					if (t.mount !== n.mount) throw new _r.ErrnoError(75);
					var u, c = _r.lookupNode(t, a),
						f = hr.relative(r, i);
					if ("." !== f.charAt(0)) throw new _r.ErrnoError(28);
					if ("." !== (f = hr.relative(e, o)).charAt(0)) throw new _r.ErrnoError(55);
					try {
						u = _r.lookupNode(n, s)
					} catch (r) {}
					if (c !== u) {
						var l = _r.isDir(c.mode),
							d = _r.mayDelete(t, a, l);
						if (d) throw new _r.ErrnoError(d);
						if (d = u ? _r.mayDelete(n, s, l) : _r.mayCreate(n, s)) throw new _r.ErrnoError(d);
						if (!t.node_ops.rename) throw new _r.ErrnoError(63);
						if (_r.isMountpoint(c) || u && _r.isMountpoint(u)) throw new _r.ErrnoError(10);
						if (n !== t && (d = _r.nodePermissions(t, "w"))) throw new _r.ErrnoError(d);
						try {
							_r.trackingDelegate.willMovePath && _r.trackingDelegate.willMovePath(r, e)
						} catch (t) {
							y("FS.trackingDelegate['willMovePath']('" + r + "', '" + e + "') threw an exception: " + t.message)
						}
						_r.hashRemoveNode(c);
						try {
							t.node_ops.rename(c, n, s)
						} catch (r) {
							throw r
						} finally {
							_r.hashAddNode(c)
						}
						try {
							_r.trackingDelegate.onMovePath && _r.trackingDelegate.onMovePath(r, e)
						} catch (t) {
							y("FS.trackingDelegate['onMovePath']('" + r + "', '" + e + "') threw an exception: " + t.message)
						}
					}
				},
				rmdir: function(r) {
					var e = _r.lookupPath(r, {
							parent: !0
						}).node,
						t = mr.basename(r),
						n = _r.lookupNode(e, t),
						o = _r.mayDelete(e, t, !0);
					if (o) throw new _r.ErrnoError(o);
					if (!e.node_ops.rmdir) throw new _r.ErrnoError(63);
					if (_r.isMountpoint(n)) throw new _r.ErrnoError(10);
					try {
						_r.trackingDelegate.willDeletePath && _r.trackingDelegate.willDeletePath(r)
					} catch (e) {
						y("FS.trackingDelegate['willDeletePath']('" + r + "') threw an exception: " + e.message)
					}
					e.node_ops.rmdir(e, t), _r.destroyNode(n);
					try {
						_r.trackingDelegate.onDeletePath && _r.trackingDelegate.onDeletePath(r)
					} catch (e) {
						y("FS.trackingDelegate['onDeletePath']('" + r + "') threw an exception: " + e.message)
					}
				},
				readdir: function(r) {
					var e = _r.lookupPath(r, {
						follow: !0
					}).node;
					if (!e.node_ops.readdir) throw new _r.ErrnoError(54);
					return e.node_ops.readdir(e)
				},
				unlink: function(r) {
					var e = _r.lookupPath(r, {
							parent: !0
						}).node,
						t = mr.basename(r),
						n = _r.lookupNode(e, t),
						o = _r.mayDelete(e, t, !1);
					if (o) throw new _r.ErrnoError(o);
					if (!e.node_ops.unlink) throw new _r.ErrnoError(63);
					if (_r.isMountpoint(n)) throw new _r.ErrnoError(10);
					try {
						_r.trackingDelegate.willDeletePath && _r.trackingDelegate.willDeletePath(r)
					} catch (e) {
						y("FS.trackingDelegate['willDeletePath']('" + r + "') threw an exception: " + e.message)
					}
					e.node_ops.unlink(e, t), _r.destroyNode(n);
					try {
						_r.trackingDelegate.onDeletePath && _r.trackingDelegate.onDeletePath(r)
					} catch (e) {
						y("FS.trackingDelegate['onDeletePath']('" + r + "') threw an exception: " + e.message)
					}
				},
				readlink: function(r) {
					var e = _r.lookupPath(r).node;
					if (!e) throw new _r.ErrnoError(44);
					if (!e.node_ops.readlink) throw new _r.ErrnoError(28);
					return hr.resolve(_r.getPath(e.parent), e.node_ops.readlink(e))
				},
				stat: function(r, e) {
					var t = _r.lookupPath(r, {
						follow: !e
					}).node;
					if (!t) throw new _r.ErrnoError(44);
					if (!t.node_ops.getattr) throw new _r.ErrnoError(63);
					return t.node_ops.getattr(t)
				},
				lstat: function(r) {
					return _r.stat(r, !0)
				},
				chmod: function(r, e, t) {
					var n;
					"string" == typeof r ? n = _r.lookupPath(r, {
						follow: !t
					}).node : n = r;
					if (!n.node_ops.setattr) throw new _r.ErrnoError(63);
					n.node_ops.setattr(n, {
						mode: 4095 & e | -4096 & n.mode,
						timestamp: Date.now()
					})
				},
				lchmod: function(r, e) {
					_r.chmod(r, e, !0)
				},
				fchmod: function(r, e) {
					var t = _r.getStream(r);
					if (!t) throw new _r.ErrnoError(8);
					_r.chmod(t.node, e)
				},
				chown: function(r, e, t, n) {
					var o;
					"string" == typeof r ? o = _r.lookupPath(r, {
						follow: !n
					}).node : o = r;
					if (!o.node_ops.setattr) throw new _r.ErrnoError(63);
					o.node_ops.setattr(o, {
						timestamp: Date.now()
					})
				},
				lchown: function(r, e, t) {
					_r.chown(r, e, t, !0)
				},
				fchown: function(r, e, t) {
					var n = _r.getStream(r);
					if (!n) throw new _r.ErrnoError(8);
					_r.chown(n.node, e, t)
				},
				truncate: function(r, e) {
					if (e < 0) throw new _r.ErrnoError(28);
					var t;
					"string" == typeof r ? t = _r.lookupPath(r, {
						follow: !0
					}).node : t = r;
					if (!t.node_ops.setattr) throw new _r.ErrnoError(63);
					if (_r.isDir(t.mode)) throw new _r.ErrnoError(31);
					if (!_r.isFile(t.mode)) throw new _r.ErrnoError(28);
					var n = _r.nodePermissions(t, "w");
					if (n) throw new _r.ErrnoError(n);
					t.node_ops.setattr(t, {
						size: e,
						timestamp: Date.now()
					})
				},
				ftruncate: function(r, e) {
					var t = _r.getStream(r);
					if (!t) throw new _r.ErrnoError(8);
					if (0 == (2097155 & t.flags)) throw new _r.ErrnoError(28);
					_r.truncate(t.node, e)
				},
				utime: function(r, e, t) {
					var n = _r.lookupPath(r, {
						follow: !0
					}).node;
					n.node_ops.setattr(n, {
						timestamp: Math.max(e, t)
					})
				},
				open: function(r, e, t, n, i) {
					if ("" === r) throw new _r.ErrnoError(44);
					var a;
					if (t = void 0 === t ? 438 : t, t = 64 & (e = "string" == typeof e ? _r.modeStringToFlags(e) : e) ? 4095 & t | 32768 : 0, "object" == typeof r) a = r;
					else {
						r = mr.normalize(r);
						try {
							a = _r.lookupPath(r, {
								follow: !(131072 & e)
							}).node
						} catch (r) {}
					}
					var s = !1;
					if (64 & e)
						if (a) {
							if (128 & e) throw new _r.ErrnoError(20)
						} else a = _r.mknod(r, t, 0), s = !0;
					if (!a) throw new _r.ErrnoError(44);
					if (_r.isChrdev(a.mode) && (e &= -513), 65536 & e && !_r.isDir(a.mode)) throw new _r.ErrnoError(54);
					if (!s) {
						var u = _r.mayOpen(a, e);
						if (u) throw new _r.ErrnoError(u)
					}
					512 & e && _r.truncate(a, 0), e &= -131713;
					var c = _r.createStream({
						node: a,
						path: _r.getPath(a),
						flags: e,
						seekable: !0,
						position: 0,
						stream_ops: a.stream_ops,
						ungotten: [],
						error: !1
					}, n, i);
					c.stream_ops.open && c.stream_ops.open(c), !o.logReadFiles || 1 & e || (_r.readFiles || (_r.readFiles = {}), r in _r.readFiles || (_r.readFiles[r] = 1, y("FS.trackingDelegate error on read file: " + r)));
					try {
						if (_r.trackingDelegate.onOpenFile) {
							var f = 0;
							1 != (2097155 & e) && (f |= _r.tracking.openFlags.READ), 0 != (2097155 & e) && (f |= _r.tracking.openFlags.WRITE), _r.trackingDelegate.onOpenFile(r, f)
						}
					} catch (e) {
						y("FS.trackingDelegate['onOpenFile']('" + r + "', flags) threw an exception: " + e.message)
					}
					return c
				},
				close: function(r) {
					if (_r.isClosed(r)) throw new _r.ErrnoError(8);
					r.getdents && (r.getdents = null);
					try {
						r.stream_ops.close && r.stream_ops.close(r)
					} catch (r) {
						throw r
					} finally {
						_r.closeStream(r.fd)
					}
					r.fd = null
				},
				isClosed: function(r) {
					return null === r.fd
				},
				llseek: function(r, e, t) {
					if (_r.isClosed(r)) throw new _r.ErrnoError(8);
					if (!r.seekable || !r.stream_ops.llseek) throw new _r.ErrnoError(70);
					if (0 != t && 1 != t && 2 != t) throw new _r.ErrnoError(28);
					return r.position = r.stream_ops.llseek(r, e, t), r.ungotten = [], r.position
				},
				read: function(r, e, t, n, o) {
					if (n < 0 || o < 0) throw new _r.ErrnoError(28);
					if (_r.isClosed(r)) throw new _r.ErrnoError(8);
					if (1 == (2097155 & r.flags)) throw new _r.ErrnoError(8);
					if (_r.isDir(r.node.mode)) throw new _r.ErrnoError(31);
					if (!r.stream_ops.read) throw new _r.ErrnoError(28);
					var i = void 0 !== o;
					if (i) {
						if (!r.seekable) throw new _r.ErrnoError(70)
					} else o = r.position;
					var a = r.stream_ops.read(r, e, t, n, o);
					return i || (r.position += a), a
				},
				write: function(r, e, t, n, o, i) {
					if (n < 0 || o < 0) throw new _r.ErrnoError(28);
					if (_r.isClosed(r)) throw new _r.ErrnoError(8);
					if (0 == (2097155 & r.flags)) throw new _r.ErrnoError(8);
					if (_r.isDir(r.node.mode)) throw new _r.ErrnoError(31);
					if (!r.stream_ops.write) throw new _r.ErrnoError(28);
					r.seekable && 1024 & r.flags && _r.llseek(r, 0, 2);
					var a = void 0 !== o;
					if (a) {
						if (!r.seekable) throw new _r.ErrnoError(70)
					} else o = r.position;
					var s = r.stream_ops.write(r, e, t, n, o, i);
					a || (r.position += s);
					try {
						r.path && _r.trackingDelegate.onWriteToFile && _r.trackingDelegate.onWriteToFile(r.path)
					} catch (e) {
						y("FS.trackingDelegate['onWriteToFile']('" + r.path + "') threw an exception: " + e.message)
					}
					return s
				},
				allocate: function(r, e, t) {
					if (_r.isClosed(r)) throw new _r.ErrnoError(8);
					if (e < 0 || t <= 0) throw new _r.ErrnoError(28);
					if (0 == (2097155 & r.flags)) throw new _r.ErrnoError(8);
					if (!_r.isFile(r.node.mode) && !_r.isDir(r.node.mode)) throw new _r.ErrnoError(43);
					if (!r.stream_ops.allocate) throw new _r.ErrnoError(138);
					r.stream_ops.allocate(r, e, t)
				},
				mmap: function(r, e, t, n, o, i) {
					if (0 != (2 & o) && 0 == (2 & i) && 2 != (2097155 & r.flags)) throw new _r.ErrnoError(2);
					if (1 == (2097155 & r.flags)) throw new _r.ErrnoError(2);
					if (!r.stream_ops.mmap) throw new _r.ErrnoError(43);
					return r.stream_ops.mmap(r, e, t, n, o, i)
				},
				msync: function(r, e, t, n, o) {
					return r && r.stream_ops.msync ? r.stream_ops.msync(r, e, t, n, o) : 0
				},
				munmap: function(r) {
					return 0
				},
				ioctl: function(r, e, t) {
					if (!r.stream_ops.ioctl) throw new _r.ErrnoError(59);
					return r.stream_ops.ioctl(r, e, t)
				},
				readFile: function(r, e) {
					if ((e = e || {}).flags = e.flags || 0, e.encoding = e.encoding || "binary", "utf8" !== e.encoding && "binary" !== e.encoding) throw new Error('Invalid encoding type "' + e.encoding + '"');
					var t, n = _r.open(r, e.flags),
						o = _r.stat(r).size,
						i = new Uint8Array(o);
					return _r.read(n, i, 0, o, 0), "utf8" === e.encoding ? t = F(i, 0) : "binary" === e.encoding && (t = i), _r.close(n), t
				},
				writeFile: function(r, e, t) {
					(t = t || {}).flags = t.flags || 577;
					var n = _r.open(r, t.flags, t.mode);
					if ("string" == typeof e) {
						var o = new Uint8Array(A(e) + 1),
							i = P(e, o, 0, o.length);
						_r.write(n, o, 0, i, void 0, t.canOwn)
					} else {
						if (!ArrayBuffer.isView(e)) throw new Error("Unsupported data type");
						_r.write(n, e, 0, e.byteLength, void 0, t.canOwn)
					}
					_r.close(n)
				},
				cwd: function() {
					return _r.currentPath
				},
				chdir: function(r) {
					var e = _r.lookupPath(r, {
						follow: !0
					});
					if (null === e.node) throw new _r.ErrnoError(44);
					if (!_r.isDir(e.node.mode)) throw new _r.ErrnoError(54);
					var t = _r.nodePermissions(e.node, "x");
					if (t) throw new _r.ErrnoError(t);
					_r.currentPath = e.path
				},
				createDefaultDirectories: function() {
					_r.mkdir("/tmp"), _r.mkdir("/home"), _r.mkdir("/home/web_user")
				},
				createDefaultDevices: function() {
					_r.mkdir("/dev"), _r.registerDevice(_r.makedev(1, 3), {
						read: function() {
							return 0
						},
						write: function(r, e, t, n, o) {
							return n
						}
					}), _r.mkdev("/dev/null", _r.makedev(1, 3)), pr.register(_r.makedev(5, 0), pr.default_tty_ops), pr.register(_r.makedev(6, 0), pr.default_tty1_ops), _r.mkdev("/dev/tty", _r.makedev(5, 0)), _r.mkdev("/dev/tty1", _r.makedev(6, 0));
					var r = function() {
						if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
							var r = new Uint8Array(1);
							return function() {
								return crypto.getRandomValues(r), r[0]
							}
						}
						if (w) try {
							var e = require("crypto");
							return function() {
								return e.randomBytes(1)[0]
							}
						} catch (r) {}
						return function() {
							rr("randomDevice")
						}
					}();
					_r.createDevice("/dev", "random", r), _r.createDevice("/dev", "urandom", r), _r.mkdir("/dev/shm"), _r.mkdir("/dev/shm/tmp")
				},
				createSpecialDirectories: function() {
					_r.mkdir("/proc");
					var r = _r.mkdir("/proc/self");
					_r.mkdir("/proc/self/fd"), _r.mount({
						mount: function() {
							var e = _r.createNode(r, "fd", 16895, 73);
							return e.node_ops = {
								lookup: function(r, e) {
									var t = +e,
										n = _r.getStream(t);
									if (!n) throw new _r.ErrnoError(8);
									var o = {
										parent: null,
										mount: {
											mountpoint: "fake"
										},
										node_ops: {
											readlink: function() {
												return n.path
											}
										}
									};
									return o.parent = o, o
								}
							}, e
						}
					}, {}, "/proc/self/fd")
				},
				createStandardStreams: function() {
					o.stdin ? _r.createDevice("/dev", "stdin", o.stdin) : _r.symlink("/dev/tty", "/dev/stdin"), o.stdout ? _r.createDevice("/dev", "stdout", null, o.stdout) : _r.symlink("/dev/tty", "/dev/stdout"), o.stderr ? _r.createDevice("/dev", "stderr", null, o.stderr) : _r.symlink("/dev/tty1", "/dev/stderr");
					_r.open("/dev/stdin", 0), _r.open("/dev/stdout", 1), _r.open("/dev/stderr", 1)
				},
				ensureErrnoError: function() {
					_r.ErrnoError || (_r.ErrnoError = function(r, e) {
						this.node = e, this.setErrno = function(r) {
							this.errno = r
						}, this.setErrno(r), this.message = "FS error"
					}, _r.ErrnoError.prototype = new Error, _r.ErrnoError.prototype.constructor = _r.ErrnoError, [44].forEach((function(r) {
						_r.genericErrors[r] = new _r.ErrnoError(r), _r.genericErrors[r].stack = "<generic error, no stack>"
					})))
				},
				staticInit: function() {
					_r.ensureErrnoError(), _r.nameTable = new Array(4096), _r.mount(wr, {}, "/"), _r.createDefaultDirectories(), _r.createDefaultDevices(), _r.createSpecialDirectories(), _r.filesystems = {
						MEMFS: wr,
						NODEFS: gr,
						WORKERFS: yr
					}
				},
				init: function(r, e, t) {
					_r.init.initialized = !0, _r.ensureErrnoError(), o.stdin = r || o.stdin, o.stdout = e || o.stdout, o.stderr = t || o.stderr, _r.createStandardStreams()
				},
				quit: function() {
					_r.init.initialized = !1;
					var r = o._fflush;
					r && r(0);
					for (var e = 0; e < _r.streams.length; e++) {
						var t = _r.streams[e];
						t && _r.close(t)
					}
				},
				getMode: function(r, e) {
					var t = 0;
					return r && (t |= 365), e && (t |= 146), t
				},
				findObject: function(r, e) {
					var t = _r.analyzePath(r, e);
					return t.exists ? t.object : null
				},
				analyzePath: function(r, e) {
					try {
						r = (n = _r.lookupPath(r, {
							follow: !e
						})).path
					} catch (r) {}
					var t = {
						isRoot: !1,
						exists: !1,
						error: 0,
						name: null,
						path: null,
						object: null,
						parentExists: !1,
						parentPath: null,
						parentObject: null
					};
					try {
						var n = _r.lookupPath(r, {
							parent: !0
						});
						t.parentExists = !0, t.parentPath = n.path, t.parentObject = n.node, t.name = mr.basename(r), n = _r.lookupPath(r, {
							follow: !e
						}), t.exists = !0, t.path = n.path, t.object = n.node, t.name = n.node.name, t.isRoot = "/" === n.path
					} catch (r) {
						t.error = r.errno
					}
					return t
				},
				createPath: function(r, e, t, n) {
					r = "string" == typeof r ? r : _r.getPath(r);
					for (var o = e.split("/").reverse(); o.length;) {
						var i = o.pop();
						if (i) {
							var a = mr.join2(r, i);
							try {
								_r.mkdir(a)
							} catch (r) {}
							r = a
						}
					}
					return a
				},
				createFile: function(r, e, t, n, o) {
					var i = mr.join2("string" == typeof r ? r : _r.getPath(r), e),
						a = _r.getMode(n, o);
					return _r.create(i, a)
				},
				createDataFile: function(r, e, t, n, o, i) {
					var a = e ? mr.join2("string" == typeof r ? r : _r.getPath(r), e) : r,
						s = _r.getMode(n, o),
						u = _r.create(a, s);
					if (t) {
						if ("string" == typeof t) {
							for (var c = new Array(t.length), f = 0, l = t.length; f < l; ++f) c[f] = t.charCodeAt(f);
							t = c
						}
						_r.chmod(u, 146 | s);
						var d = _r.open(u, 577);
						_r.write(d, t, 0, t.length, 0, i), _r.close(d), _r.chmod(u, s)
					}
					return u
				},
				createDevice: function(r, e, t, n) {
					var o = mr.join2("string" == typeof r ? r : _r.getPath(r), e),
						i = _r.getMode(!!t, !!n);
					_r.createDevice.major || (_r.createDevice.major = 64);
					var a = _r.makedev(_r.createDevice.major++, 0);
					return _r.registerDevice(a, {
						open: function(r) {
							r.seekable = !1
						},
						close: function(r) {
							n && n.buffer && n.buffer.length && n(10)
						},
						read: function(r, e, n, o, i) {
							for (var a = 0, s = 0; s < o; s++) {
								var u;
								try {
									u = t()
								} catch (r) {
									throw new _r.ErrnoError(29)
								}
								if (void 0 === u && 0 === a) throw new _r.ErrnoError(6);
								if (null == u) break;
								a++, e[n + s] = u
							}
							return a && (r.node.timestamp = Date.now()), a
						},
						write: function(r, e, t, o, i) {
							for (var a = 0; a < o; a++) try {
								n(e[t + a])
							} catch (r) {
								throw new _r.ErrnoError(29)
							}
							return o && (r.node.timestamp = Date.now()), a
						}
					}), _r.mkdev(o, i, a)
				},
				forceLoadFile: function(r) {
					if (r.isDevice || r.isFolder || r.link || r.contents) return !0;
					if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
					if (!s) throw new Error("Cannot load without read() or XMLHttpRequest.");
					try {
						r.contents = Mr(s(r.url), !0), r.usedBytes = r.contents.length
					} catch (r) {
						throw new _r.ErrnoError(29)
					}
				},
				createLazyFile: function(r, e, t, n, o) {
					function i() {
						this.lengthKnown = !1, this.chunks = []
					}
					if (i.prototype.get = function(r) {
							if (!(r > this.length - 1 || r < 0)) {
								var e = r % this.chunkSize,
									t = r / this.chunkSize | 0;
								return this.getter(t)[e]
							}
						}, i.prototype.setDataGetter = function(r) {
							this.getter = r
						}, i.prototype.cacheLength = function() {
							var r = new XMLHttpRequest;
							if (r.open("HEAD", t, !1), r.send(null), !(r.status >= 200 && r.status < 300 || 304 === r.status)) throw new Error("Couldn't load " + t + ". Status: " + r.status);
							var e, n = Number(r.getResponseHeader("Content-length")),
								o = (e = r.getResponseHeader("Accept-Ranges")) && "bytes" === e,
								i = (e = r.getResponseHeader("Content-Encoding")) && "gzip" === e,
								a = 1048576;
							o || (a = n);
							var s = this;
							s.setDataGetter((function(r) {
								var e = r * a,
									o = (r + 1) * a - 1;
								if (o = Math.min(o, n - 1), void 0 === s.chunks[r] && (s.chunks[r] = function(r, e) {
										if (r > e) throw new Error("invalid range (" + r + ", " + e + ") or no bytes requested!");
										if (e > n - 1) throw new Error("only " + n + " bytes available! programmer error!");
										var o = new XMLHttpRequest;
										if (o.open("GET", t, !1), n !== a && o.setRequestHeader("Range", "bytes=" + r + "-" + e), "undefined" != typeof Uint8Array && (o.responseType = "arraybuffer"), o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.send(null), !(o.status >= 200 && o.status < 300 || 304 === o.status)) throw new Error("Couldn't load " + t + ". Status: " + o.status);
										return void 0 !== o.response ? new Uint8Array(o.response || []) : Mr(o.responseText || "", !0)
									}(e, o)), void 0 === s.chunks[r]) throw new Error("doXHR failed!");
								return s.chunks[r]
							})), !i && n || (a = n = 1, n = this.getter(0).length, a = n, g("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = n, this._chunkSize = a, this.lengthKnown = !0
						}, "undefined" != typeof XMLHttpRequest) {
						if (!E) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
						var a = new i;
						Object.defineProperties(a, {
							length: {
								get: function() {
									return this.lengthKnown || this.cacheLength(), this._length
								}
							},
							chunkSize: {
								get: function() {
									return this.lengthKnown || this.cacheLength(), this._chunkSize
								}
							}
						});
						var s = {
							isDevice: !1,
							contents: a
						}
					} else s = {
						isDevice: !1,
						url: t
					};
					var u = _r.createFile(r, e, s, n, o);
					s.contents ? u.contents = s.contents : s.url && (u.contents = null, u.url = s.url), Object.defineProperties(u, {
						usedBytes: {
							get: function() {
								return this.contents.length
							}
						}
					});
					var c = {};
					return Object.keys(u.stream_ops).forEach((function(r) {
						var e = u.stream_ops[r];
						c[r] = function() {
							return _r.forceLoadFile(u), e.apply(null, arguments)
						}
					})), c.read = function(r, e, t, n, o) {
						_r.forceLoadFile(u);
						var i = r.node.contents;
						if (o >= i.length) return 0;
						var a = Math.min(i.length - o, n);
						if (i.slice)
							for (var s = 0; s < a; s++) e[t + s] = i[o + s];
						else
							for (s = 0; s < a; s++) e[t + s] = i.get(o + s);
						return a
					}, u.stream_ops = c, u
				},
				createPreloadedFile: function(r, e, t, n, i, a, s, c, f, l) {
					Browser.init();
					var d = e ? hr.resolve(mr.join2(r, e)) : r;

					function m(t) {
						function u(t) {
							l && l(), c || _r.createDataFile(r, e, t, n, i, f), a && a(), J()
						}
						var m = !1;
						o.preloadPlugins.forEach((function(r) {
							m || r.canHandle(d) && (r.handle(t, d, u, (function() {
								s && s(), J()
							})), m = !0)
						})), m || u(t)
					}
					$(), "string" == typeof t ? function(r, e, t, n) {
						var o = n ? "" : "al " + r;
						u(r, (function(t) {
							N(t, 'Loading data file "' + r + '" failed (no arrayBuffer).'), e(new Uint8Array(t)), o && J()
						}), (function(e) {
							if (!t) throw 'Loading data file "' + r + '" failed.';
							t()
						})), o && $()
					}(t, (function(r) {
						m(r)
					}), s) : m(t)
				},
				indexedDB: function() {
					return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB
				},
				DB_NAME: function() {
					return "EM_FS_" + window.location.pathname
				},
				DB_VERSION: 20,
				DB_STORE_NAME: "FILE_DATA",
				saveFilesToDB: function(r, e, t) {
					e = e || function() {}, t = t || function() {};
					var n = _r.indexedDB();
					try {
						var o = n.open(_r.DB_NAME(), _r.DB_VERSION)
					} catch (r) {
						return t(r)
					}
					o.onupgradeneeded = function() {
						g("creating db"), o.result.createObjectStore(_r.DB_STORE_NAME)
					}, o.onsuccess = function() {
						var n = o.result.transaction([_r.DB_STORE_NAME], "readwrite"),
							i = n.objectStore(_r.DB_STORE_NAME),
							a = 0,
							s = 0,
							u = r.length;

						function c() {
							0 == s ? e() : t()
						}
						r.forEach((function(r) {
							var e = i.put(_r.analyzePath(r).object.contents, r);
							e.onsuccess = function() {
								++a + s == u && c()
							}, e.onerror = function() {
								s++, a + s == u && c()
							}
						})), n.onerror = t
					}, o.onerror = t
				},
				loadFilesFromDB: function(r, e, t) {
					e = e || function() {}, t = t || function() {};
					var n = _r.indexedDB();
					try {
						var o = n.open(_r.DB_NAME(), _r.DB_VERSION)
					} catch (r) {
						return t(r)
					}
					o.onupgradeneeded = t, o.onsuccess = function() {
						var n = o.result;
						try {
							var i = n.transaction([_r.DB_STORE_NAME], "readonly")
						} catch (r) {
							return void t(r)
						}
						var a = i.objectStore(_r.DB_STORE_NAME),
							s = 0,
							u = 0,
							c = r.length;

						function f() {
							0 == u ? e() : t()
						}
						r.forEach((function(r) {
							var e = a.get(r);
							e.onsuccess = function() {
								_r.analyzePath(r).exists && _r.unlink(r), _r.createDataFile(mr.dirname(r), mr.basename(r), e.result, !0, !0, !0), ++s + u == c && f()
							}, e.onerror = function() {
								u++, s + u == c && f()
							}
						})), i.onerror = t
					}, o.onerror = t
				}
			},
			kr = {
				mappings: {},
				DEFAULT_POLLMASK: 5,
				umask: 511,
				calculateAt: function(r, e, t) {
					if ("/" === e[0]) return e;
					var n;
					if (-100 === r) n = _r.cwd();
					else {
						var o = _r.getStream(r);
						if (!o) throw new _r.ErrnoError(8);
						n = o.path
					}
					if (0 == e.length) {
						if (!t) throw new _r.ErrnoError(44);
						return n
					}
					return mr.join2(n, e)
				},
				doStat: function(r, e, t) {
					try {
						var n = r(e)
					} catch (r) {
						if (r && r.node && mr.normalize(e) !== mr.normalize(_r.getPath(r.node))) return -54;
						throw r
					}
					return I[t >> 2] = n.dev, I[t + 4 >> 2] = 0, I[t + 8 >> 2] = n.ino, I[t + 12 >> 2] = n.mode, I[t + 16 >> 2] = n.nlink, I[t + 20 >> 2] = n.uid, I[t + 24 >> 2] = n.gid, I[t + 28 >> 2] = n.rdev, I[t + 32 >> 2] = 0, or = [n.size >>> 0, (nr = n.size, +Math.abs(nr) >= 1 ? nr > 0 ? (0 | Math.min(+Math.floor(nr / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((nr - +(~~nr >>> 0)) / 4294967296) >>> 0 : 0)], I[t + 40 >> 2] = or[0], I[t + 44 >> 2] = or[1], I[t + 48 >> 2] = 4096, I[t + 52 >> 2] = n.blocks, I[t + 56 >> 2] = n.atime.getTime() / 1e3 | 0, I[t + 60 >> 2] = 0, I[t + 64 >> 2] = n.mtime.getTime() / 1e3 | 0, I[t + 68 >> 2] = 0, I[t + 72 >> 2] = n.ctime.getTime() / 1e3 | 0, I[t + 76 >> 2] = 0, or = [n.ino >>> 0, (nr = n.ino, +Math.abs(nr) >= 1 ? nr > 0 ? (0 | Math.min(+Math.floor(nr / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((nr - +(~~nr >>> 0)) / 4294967296) >>> 0 : 0)], I[t + 80 >> 2] = or[0], I[t + 84 >> 2] = or[1], 0
				},
				doMsync: function(r, e, t, n, o) {
					var i = z.slice(r, r + t);
					_r.msync(e, i, o, t, n)
				},
				doMkdir: function(r, e) {
					return "/" === (r = mr.normalize(r))[r.length - 1] && (r = r.substr(0, r.length - 1)), _r.mkdir(r, e, 0), 0
				},
				doMknod: function(r, e, t) {
					switch (61440 & e) {
						case 32768:
						case 8192:
						case 24576:
						case 4096:
						case 49152:
							break;
						default:
							return -28
					}
					return _r.mknod(r, e, t), 0
				},
				doReadlink: function(r, e, t) {
					if (t <= 0) return -28;
					var n = _r.readlink(r),
						o = Math.min(t, A(n)),
						i = C[e + o];
					return M(n, e, t + 1), C[e + o] = i, o
				},
				doAccess: function(r, e) {
					if (-8 & e) return -28;
					var t;
					if (!(t = _r.lookupPath(r, {
							follow: !0
						}).node)) return -44;
					var n = "";
					return 4 & e && (n += "r"), 2 & e && (n += "w"), 1 & e && (n += "x"), n && _r.nodePermissions(t, n) ? -2 : 0
				},
				doDup: function(r, e, t) {
					var n = _r.getStream(t);
					return n && _r.close(n), _r.open(r, e, 0, t, t).fd
				},
				doReadv: function(r, e, t, n) {
					for (var o = 0, i = 0; i < t; i++) {
						var a = I[e + 8 * i >> 2],
							s = I[e + (8 * i + 4) >> 2],
							u = _r.read(r, C, a, s, n);
						if (u < 0) return -1;
						if (o += u, u < s) break
					}
					return o
				},
				doWritev: function(r, e, t, n) {
					for (var o = 0, i = 0; i < t; i++) {
						var a = I[e + 8 * i >> 2],
							s = I[e + (8 * i + 4) >> 2],
							u = _r.write(r, C, a, s, n);
						if (u < 0) return -1;
						o += u
					}
					return o
				},
				varargs: void 0,
				get: function() {
					return kr.varargs += 4, I[kr.varargs - 4 >> 2]
				},
				getStr: function(r) {
					return T(r)
				},
				getStreamFromFD: function(r) {
					var e = _r.getStream(r);
					if (!e) throw new _r.ErrnoError(8);
					return e
				},
				get64: function(r, e) {
					return r
				}
			};

		function Dr(r) {
			try {
				return k.grow(r - R.byteLength + 65535 >>> 16), U(k.buffer), 1
			} catch (r) {}
		}
		var Sr = {};

		function br() {
			if (!br.strings) {
				var r = {
					USER: "web_user",
					LOGNAME: "web_user",
					PATH: "/",
					PWD: "/",
					HOME: "/home/web_user",
					LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
					_: m || "./this.program"
				};
				for (var e in Sr) void 0 === Sr[e] ? delete r[e] : r[e] = Sr[e];
				var t = [];
				for (var e in r) t.push(e + "=" + r[e]);
				br.strings = t
			}
			return br.strings
		}
		var Nr = function(r, e, t, n) {
				r || (r = this), this.parent = r, this.mount = r.mount, this.mounted = null, this.id = _r.nextInode++, this.name = e, this.mode = t, this.node_ops = {}, this.stream_ops = {}, this.rdev = n
			},
			Or = 365,
			Fr = 146;
		if (Object.defineProperties(Nr.prototype, {
				read: {
					get: function() {
						return (this.mode & Or) === Or
					},
					set: function(r) {
						r ? this.mode |= Or : this.mode &= -366
					}
				},
				write: {
					get: function() {
						return (this.mode & Fr) === Fr
					},
					set: function(r) {
						r ? this.mode |= Fr : this.mode &= -147
					}
				},
				isFolder: {
					get: function() {
						return _r.isDir(this.mode)
					}
				},
				isDevice: {
					get: function() {
						return _r.isChrdev(this.mode)
					}
				}
			}), _r.FSNode = Nr, _r.staticInit(), w) {
			var Tr = require("fs"),
				Pr = require("path");
			gr.staticInit()
		}
		vr = {
			EPERM: 63,
			ENOENT: 44,
			ESRCH: 71,
			EINTR: 27,
			EIO: 29,
			ENXIO: 60,
			E2BIG: 1,
			ENOEXEC: 45,
			EBADF: 8,
			ECHILD: 12,
			EAGAIN: 6,
			EWOULDBLOCK: 6,
			ENOMEM: 48,
			EACCES: 2,
			EFAULT: 21,
			ENOTBLK: 105,
			EBUSY: 10,
			EEXIST: 20,
			EXDEV: 75,
			ENODEV: 43,
			ENOTDIR: 54,
			EISDIR: 31,
			EINVAL: 28,
			ENFILE: 41,
			EMFILE: 33,
			ENOTTY: 59,
			ETXTBSY: 74,
			EFBIG: 22,
			ENOSPC: 51,
			ESPIPE: 70,
			EROFS: 69,
			EMLINK: 34,
			EPIPE: 64,
			EDOM: 18,
			ERANGE: 68,
			ENOMSG: 49,
			EIDRM: 24,
			ECHRNG: 106,
			EL2NSYNC: 156,
			EL3HLT: 107,
			EL3RST: 108,
			ELNRNG: 109,
			EUNATCH: 110,
			ENOCSI: 111,
			EL2HLT: 112,
			EDEADLK: 16,
			ENOLCK: 46,
			EBADE: 113,
			EBADR: 114,
			EXFULL: 115,
			ENOANO: 104,
			EBADRQC: 103,
			EBADSLT: 102,
			EDEADLOCK: 16,
			EBFONT: 101,
			ENOSTR: 100,
			ENODATA: 116,
			ETIME: 117,
			ENOSR: 118,
			ENONET: 119,
			ENOPKG: 120,
			EREMOTE: 121,
			ENOLINK: 47,
			EADV: 122,
			ESRMNT: 123,
			ECOMM: 124,
			EPROTO: 65,
			EMULTIHOP: 36,
			EDOTDOT: 125,
			EBADMSG: 9,
			ENOTUNIQ: 126,
			EBADFD: 127,
			EREMCHG: 128,
			ELIBACC: 129,
			ELIBBAD: 130,
			ELIBSCN: 131,
			ELIBMAX: 132,
			ELIBEXEC: 133,
			ENOSYS: 52,
			ENOTEMPTY: 55,
			ENAMETOOLONG: 37,
			ELOOP: 32,
			EOPNOTSUPP: 138,
			EPFNOSUPPORT: 139,
			ECONNRESET: 15,
			ENOBUFS: 42,
			EAFNOSUPPORT: 5,
			EPROTOTYPE: 67,
			ENOTSOCK: 57,
			ENOPROTOOPT: 50,
			ESHUTDOWN: 140,
			ECONNREFUSED: 14,
			EADDRINUSE: 3,
			ECONNABORTED: 13,
			ENETUNREACH: 40,
			ENETDOWN: 38,
			ETIMEDOUT: 73,
			EHOSTDOWN: 142,
			EHOSTUNREACH: 23,
			EINPROGRESS: 26,
			EALREADY: 7,
			EDESTADDRREQ: 17,
			EMSGSIZE: 35,
			EPROTONOSUPPORT: 66,
			ESOCKTNOSUPPORT: 137,
			EADDRNOTAVAIL: 4,
			ENETRESET: 39,
			EISCONN: 30,
			ENOTCONN: 53,
			ETOOMANYREFS: 141,
			EUSERS: 136,
			EDQUOT: 19,
			ESTALE: 72,
			ENOTSUP: 138,
			ENOMEDIUM: 148,
			EILSEQ: 25,
			EOVERFLOW: 61,
			ECANCELED: 11,
			ENOTRECOVERABLE: 56,
			EOWNERDEAD: 62,
			ESTRPIPE: 135
		};

		function Mr(r, e, t) {
			var n = t > 0 ? t : A(r) + 1,
				o = new Array(n),
				i = P(r, o, 0, o.length);
			return e && (o.length = i), o
		}
		var Ar, Rr = {
				__cxa_allocate_exception: function(r) {
					return Cr(r + 16) + 16
				},
				__cxa_atexit: function(r, e) {},
				__cxa_throw: function(r, e, t) {
					throw new fr(r).init(e, t), r, r
				},
				__gmtime_r: function(r, e) {
					return lr(r, e)
				},
				__localtime_r: function(r, e) {
					return function(r, e) {
						dr();
						var t = new Date(1e3 * I[r >> 2]);
						I[e >> 2] = t.getSeconds(), I[e + 4 >> 2] = t.getMinutes(), I[e + 8 >> 2] = t.getHours(), I[e + 12 >> 2] = t.getDate(), I[e + 16 >> 2] = t.getMonth(), I[e + 20 >> 2] = t.getFullYear() - 1900, I[e + 24 >> 2] = t.getDay();
						var n = new Date(t.getFullYear(), 0, 1),
							o = (t.getTime() - n.getTime()) / 864e5 | 0;
						I[e + 28 >> 2] = o, I[e + 36 >> 2] = -60 * t.getTimezoneOffset();
						var i = new Date(t.getFullYear(), 6, 1).getTimezoneOffset(),
							a = n.getTimezoneOffset(),
							s = 0 | (i != a && t.getTimezoneOffset() == Math.min(a, i));
						I[e + 32 >> 2] = s;
						var u = I[zr() + (s ? 4 : 0) >> 2];
						return I[e + 40 >> 2] = u, e
					}(r, e)
				},
				__sys_chmod: function(r, e) {
					try {
						return r = kr.getStr(r), _r.chmod(r, e), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_chown32: function(r, e, t) {
					try {
						return r = kr.getStr(r), _r.chown(r, e, t), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_fstat64: function(r, e) {
					try {
						var t = kr.getStreamFromFD(r);
						return kr.doStat(_r.stat, t.path, e)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_fstatat64: function(r, e, t, n) {
					try {
						e = kr.getStr(e);
						var o = 256 & n,
							i = 4096 & n;
						return n &= -4353, e = kr.calculateAt(r, e, i), kr.doStat(o ? _r.lstat : _r.stat, e, t)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_ftruncate64: function(r, e, t, n) {
					try {
						var o = kr.get64(t, n);
						return _r.ftruncate(r, o), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_getcwd: function(r, e) {
					try {
						if (0 === e) return -28;
						var t = _r.cwd();
						return e < A(t) + 1 ? -68 : (M(t, r, e), r)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_getdents64: function(r, e, t) {
					try {
						var n = kr.getStreamFromFD(r);
						n.getdents || (n.getdents = _r.readdir(n.path));
						for (var o = 280, i = 0, a = _r.llseek(n, 0, 1), s = Math.floor(a / o); s < n.getdents.length && i + o <= t;) {
							var u, c, f = n.getdents[s];
							if ("." === f[0]) u = 1, c = 4;
							else {
								var l = _r.lookupNode(n.node, f);
								u = l.id, c = _r.isChrdev(l.mode) ? 2 : _r.isDir(l.mode) ? 4 : _r.isLink(l.mode) ? 10 : 8
							}
							or = [u >>> 0, (nr = u, +Math.abs(nr) >= 1 ? nr > 0 ? (0 | Math.min(+Math.floor(nr / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((nr - +(~~nr >>> 0)) / 4294967296) >>> 0 : 0)], I[e + i >> 2] = or[0], I[e + i + 4 >> 2] = or[1], or = [(s + 1) * o >>> 0, (nr = (s + 1) * o, +Math.abs(nr) >= 1 ? nr > 0 ? (0 | Math.min(+Math.floor(nr / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((nr - +(~~nr >>> 0)) / 4294967296) >>> 0 : 0)], I[e + i + 8 >> 2] = or[0], I[e + i + 12 >> 2] = or[1], L[e + i + 16 >> 1] = 280, C[e + i + 18 >> 0] = c, M(f, e + i + 19, 256), i += o, s += 1
						}
						return _r.llseek(n, s * o, 0), i
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_getpid: function() {
					return 42
				},
				__sys_getppid: function() {
					return 1
				},
				__sys_ioctl: function(r, e, t) {
					kr.varargs = t;
					try {
						var n = kr.getStreamFromFD(r);
						switch (e) {
							case 21509:
							case 21505:
							case 21510:
							case 21511:
							case 21512:
							case 21506:
							case 21507:
							case 21508:
							case 21523:
							case 21524:
								return n.tty ? 0 : -59;
							case 21519:
								if (!n.tty) return -59;
								var o = kr.get();
								return I[o >> 2] = 0, 0;
							case 21520:
								return n.tty ? -28 : -59;
							case 21531:
								o = kr.get();
								return _r.ioctl(n, e, o);
							default:
								rr("bad ioctl syscall " + e)
						}
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_link: function(r, e) {
					return -34
				},
				__sys_lstat64: function(r, e) {
					try {
						return r = kr.getStr(r), kr.doStat(_r.lstat, r, e)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_mkdir: function(r, e) {
					try {
						return r = kr.getStr(r), kr.doMkdir(r, e)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_open: function(r, e, t) {
					kr.varargs = t;
					try {
						var n = kr.getStr(r),
							o = t ? kr.get() : 0;
						return _r.open(n, e, o).fd
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_readlink: function(r, e, t) {
					try {
						return r = kr.getStr(r), kr.doReadlink(r, e, t)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_rename: function(r, e) {
					try {
						return r = kr.getStr(r), e = kr.getStr(e), _r.rename(r, e), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_rmdir: function(r) {
					try {
						return r = kr.getStr(r), _r.rmdir(r), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_stat64: function(r, e) {
					try {
						return r = kr.getStr(r), kr.doStat(_r.stat, r, e)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_symlink: function(r, e) {
					try {
						return r = kr.getStr(r), e = kr.getStr(e), _r.symlink(r, e), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_umask: function(r) {
					try {
						var e = kr.umask;
						return kr.umask = r, e
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_uname: function(r) {
					try {
						if (!r) return -21;
						var e = {
								__size__: 390,
								domainname: 325,
								machine: 260,
								nodename: 65,
								release: 130,
								sysname: 0,
								version: 195
							},
							t = function(t, n) {
								j(n, r + e[t])
							};
						return t("sysname", "Emscripten"), t("nodename", "emscripten"), t("release", "1.0"), t("version", "#1"), t("machine", "wasm32"), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_unlink: function(r) {
					try {
						return r = kr.getStr(r), _r.unlink(r), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				__sys_utimensat: function(r, e, t, n) {
					try {
						e = kr.getStr(e), e = kr.calculateAt(r, e, !0);
						var o = I[t >> 2],
							i = I[t + 4 >> 2],
							a = 1e3 * o + i / 1e6,
							s = 1e3 * (o = I[(t += 8) >> 2]) + (i = I[t + 4 >> 2]) / 1e6;
						return _r.utime(e, a, s), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), -r.errno
					}
				},
				abort: function() {
					rr()
				},
				emscripten_get_heap_max: function() {
					return 2147483648
				},
				emscripten_memcpy_big: function(r, e, t) {
					z.copyWithin(r, e, e + t)
				},
				emscripten_resize_heap: function(r) {
					var e, t, n = z.length,
						o = 2147483648;
					if ((r >>>= 0) > o) return !1;
					for (var i = 1; i <= 4; i *= 2) {
						var a = n * (1 + .2 / i);
						if (a = Math.min(a, r + 100663296), Dr(Math.min(o, ((e = Math.max(r, a)) % (t = 65536) > 0 && (e += t - e % t), e)))) return !0
					}
					return !1
				},
				environ_get: function(r, e) {
					var t = 0;
					return br().forEach((function(n, o) {
						var i = e + t;
						I[r + 4 * o >> 2] = i, j(n, i), t += n.length + 1
					})), 0
				},
				environ_sizes_get: function(r, e) {
					var t = br();
					I[r >> 2] = t.length;
					var n = 0;
					return t.forEach((function(r) {
						n += r.length + 1
					})), I[e >> 2] = n, 0
				},
				exit: function(r) {
					Hr(r)
				},
				fd_close: function(r) {
					try {
						var e = kr.getStreamFromFD(r);
						return _r.close(e), 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), r.errno
					}
				},
				fd_fdstat_get: function(r, e) {
					try {
						var t = kr.getStreamFromFD(r),
							n = t.tty ? 2 : _r.isDir(t.mode) ? 3 : _r.isLink(t.mode) ? 7 : 4;
						return C[e >> 0] = n, 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), r.errno
					}
				},
				fd_read: function(r, e, t, n) {
					try {
						var o = kr.getStreamFromFD(r),
							i = kr.doReadv(o, e, t);
						return I[n >> 2] = i, 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), r.errno
					}
				},
				fd_seek: function(r, e, t, n, o) {
					try {
						var i = kr.getStreamFromFD(r),
							a = 4294967296 * t + (e >>> 0),
							s = 9007199254740992;
						return a <= -s || a >= s ? -61 : (_r.llseek(i, a, n), or = [i.position >>> 0, (nr = i.position, +Math.abs(nr) >= 1 ? nr > 0 ? (0 | Math.min(+Math.floor(nr / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((nr - +(~~nr >>> 0)) / 4294967296) >>> 0 : 0)], I[o >> 2] = or[0], I[o + 4 >> 2] = or[1], i.getdents && 0 === a && 0 === n && (i.getdents = null), 0)
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), r.errno
					}
				},
				fd_write: function(r, e, t, n) {
					try {
						var o = kr.getStreamFromFD(r),
							i = kr.doWritev(o, e, t);
						return I[n >> 2] = i, 0
					} catch (r) {
						return void 0 !== _r && r instanceof _r.ErrnoError || rr(r), r.errno
					}
				},
				getgrgid: function() {
					throw "getgrgid: TODO"
				},
				getpwuid: function() {
					throw "getpwuid: TODO"
				},
				gettimeofday: function(r) {
					var e = Date.now();
					return I[r >> 2] = e / 1e3 | 0, I[r + 4 >> 2] = e % 1e3 * 1e3 | 0, 0
				},
				mktime: function(r) {
					dr();
					var e = new Date(I[r + 20 >> 2] + 1900, I[r + 16 >> 2], I[r + 12 >> 2], I[r + 8 >> 2], I[r + 4 >> 2], I[r >> 2], 0),
						t = I[r + 32 >> 2],
						n = e.getTimezoneOffset(),
						o = new Date(e.getFullYear(), 0, 1),
						i = new Date(e.getFullYear(), 6, 1).getTimezoneOffset(),
						a = o.getTimezoneOffset(),
						s = Math.min(a, i);
					if (t < 0) I[r + 32 >> 2] = Number(i != a && s == n);
					else if (t > 0 != (s == n)) {
						var u = Math.max(a, i),
							c = t > 0 ? s : u;
						e.setTime(e.getTime() + 6e4 * (c - n))
					}
					I[r + 24 >> 2] = e.getDay();
					var f = (e.getTime() - o.getTime()) / 864e5 | 0;
					return I[r + 28 >> 2] = f, I[r >> 2] = e.getSeconds(), I[r + 4 >> 2] = e.getMinutes(), I[r + 8 >> 2] = e.getHours(), I[r + 12 >> 2] = e.getDate(), I[r + 16 >> 2] = e.getMonth(), e.getTime() / 1e3 | 0
				},
				setTempRet0: function(r) {
					r
				},
				time: function(r) {
					var e = Date.now() / 1e3 | 0;
					return r && (I[r >> 2] = e), e
				},
				times: function(r) {
					var e, t;
					return 0 !== r && (e = r, t = 16, z.fill(0, e, e + t)), 0
				}
			},
			Cr = (function() {
				var r = {
					env: Rr,
					wasi_snapshot_preview1: Rr
				};

				function e(r, e) {
					var t, n = r.exports;
					o.asm = n, U((k = o.asm.memory).buffer), H = o.asm.__indirect_function_table, t = o.asm.__wasm_call_ctors, q.unshift(t), J()
				}

				function t(r) {
					e(r.instance)
				}

				function i(e) {
					return function() {
						if (!_ && (p || E)) {
							if ("function" == typeof fetch && !sr(er)) return fetch(er, {
								credentials: "same-origin"
							}).then((function(r) {
								if (!r.ok) throw "failed to load wasm binary file at '" + er + "'";
								return r.arrayBuffer()
							})).catch((function() {
								return ur(er)
							}));
							if (u) return new Promise((function(r, e) {
								u(er, (function(e) {
									r(new Uint8Array(e))
								}), e)
							}))
						}
						return Promise.resolve().then((function() {
							return ur(er)
						}))
					}().then((function(e) {
						return WebAssembly.instantiate(e, r)
					})).then((function(r) {
						return r
					})).then(e, (function(r) {
						y("failed to asynchronously prepare wasm: " + r), rr(r)
					}))
				}
				if ($(), o.instantiateWasm) try {
					return o.instantiateWasm(r, e)
				} catch (r) {
					return y("Module.instantiateWasm callback failed with error: " + r), !1
				}(_ || "function" != typeof WebAssembly.instantiateStreaming || ar(er) || sr(er) || "function" != typeof fetch ? i(t) : fetch(er, {
					credentials: "same-origin"
				}).then((function(e) {
					return WebAssembly.instantiateStreaming(e, r).then(t, (function(r) {
						return y("wasm streaming compile failed: " + r), y("falling back to ArrayBuffer instantiation"), i(t)
					}))
				}))).catch(n)
			}(), o.___wasm_call_ctors = function() {
				return (o.___wasm_call_ctors = o.asm.__wasm_call_ctors).apply(null, arguments)
			}, o._malloc = function() {
				return (Cr = o._malloc = o.asm.malloc).apply(null, arguments)
			}),
			zr = (o.___errno_location = function() {
				return (o.___errno_location = o.asm.__errno_location).apply(null, arguments)
			}, o._main = function() {
				return (o._main = o.asm.main).apply(null, arguments)
			}, o.__get_tzname = function() {
				return (zr = o.__get_tzname = o.asm._get_tzname).apply(null, arguments)
			}),
			Lr = o.__get_daylight = function() {
				return (Lr = o.__get_daylight = o.asm._get_daylight).apply(null, arguments)
			},
			Ir = o.__get_timezone = function() {
				return (Ir = o.__get_timezone = o.asm._get_timezone).apply(null, arguments)
			},
			xr = (o.stackSave = function() {
				return (o.stackSave = o.asm.stackSave).apply(null, arguments)
			}, o.stackRestore = function() {
				return (o.stackRestore = o.asm.stackRestore).apply(null, arguments)
			}, o.stackAlloc = function() {
				return (xr = o.stackAlloc = o.asm.stackAlloc).apply(null, arguments)
			});
		o.dynCall_iijj = function() {
			return (o.dynCall_iijj = o.asm.dynCall_iijj).apply(null, arguments)
		}, o.dynCall_iijii = function() {
			return (o.dynCall_iijii = o.asm.dynCall_iijii).apply(null, arguments)
		}, o.dynCall_jii = function() {
			return (o.dynCall_jii = o.asm.dynCall_jii).apply(null, arguments)
		}, o.dynCall_iiji = function() {
			return (o.dynCall_iiji = o.asm.dynCall_iiji).apply(null, arguments)
		}, o.dynCall_iij = function() {
			return (o.dynCall_iij = o.asm.dynCall_iij).apply(null, arguments)
		}, o.dynCall_vij = function() {
			return (o.dynCall_vij = o.asm.dynCall_vij).apply(null, arguments)
		}, o.dynCall_iiij = function() {
			return (o.dynCall_iiij = o.asm.dynCall_iiij).apply(null, arguments)
		}, o.dynCall_jiji = function() {
			return (o.dynCall_jiji = o.asm.dynCall_jiji).apply(null, arguments)
		};

		function Br(r) {
			this.name = "ExitStatus", this.message = "Program terminated with exit(" + r + ")", this.status = r
		}

		function jr(r) {
			var e = o._main,
				t = (r = r || []).length + 1,
				n = xr(4 * (t + 1));
			I[n >> 2] = B(m);
			for (var i = 1; i < t; i++) I[(n >> 2) + i] = B(r[i - 1]);
			I[(n >> 2) + t] = 0;
			try {
				var a = e(t, n);
				return Hr(a, !0), a
			} catch (r) {
				return function(r) {
					if (r instanceof Br || "unwind" == r) return S;
					y("exception thrown: " + r), h(1, r)
				}(r)
			} finally {
				!0
			}
		}

		function Ur(r) {
			function e() {
				Ar || (Ar = !0, o.calledRun = !0, b || (!0, o.noFSInit || _r.init.initialized || _r.init(), _r.ignorePermissions = !1, pr.init(), cr(q), cr(G), t(o), o.onRuntimeInitialized && o.onRuntimeInitialized(), Wr && jr(r), function() {
					if (o.postRun)
						for ("function" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length;) r = o.postRun.shift(), Y.unshift(r);
					var r;
					cr(Y)
				}()))
			}
			r = r || d, V > 0 || (! function() {
				if (o.preRun)
					for ("function" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length;) r = o.preRun.shift(), W.unshift(r);
				var r;
				cr(W)
			}(), V > 0 || (o.setStatus ? (o.setStatus("Running..."), setTimeout((function() {
				setTimeout((function() {
					o.setStatus("")
				}), 1), e()
			}), 1)) : e()))
		}

		function Hr(r, e) {
			S = r, K() || !0,
				function(r) {
					S = r, K() || (o.onExit && o.onExit(r), b = !0);
					h(r, new Br(r))
				}(r)
		}
		if (Z = function r() {
				Ar || Ur(), Ar || (Z = r)
			}, o.run = Ur, o.preInit)
			for ("function" == typeof o.preInit && (o.preInit = [o.preInit]); o.preInit.length > 0;) o.preInit.pop()();
		var Wr = !0;
		return o.noInitialRun && (Wr = !1), Ur(), o.FS = _r, o.NODEFS = gr, o.WORKERFS = yr, o.callMain = jr, e.ready
	}
}();
export default SevenZip;
//# sourceMappingURL=/sm/270025a5d5125e7586ed18bbebfffc4241c7077e3a01b81854312669feab14bb.map